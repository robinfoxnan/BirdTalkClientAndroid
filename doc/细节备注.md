# 备注



# 1. 数据库

## 1.1 基础表

```kotlin 
public class BaseDb extends SQLiteOpenHelper 
```

初始化方法，当登录成功时候，通过用户ID加载当前实例，这样的设计主要是为了支持客户端使用多账户登录。

```kotlin
// 获取数据库实例
BaseDb.changeToDB(this.requireActivity(), "1234")
```

这个函数在实例创建时候会检查并创建各种表：

```kotlin
// Create your tables here
 UserDbHelper.onCreate(db);
 TopicDbHelper.onCreate(db);
```

但是，客户端每个会话是单独存储消息的，索引这里需要维护动态创建表的情况：

```
// 标记聊天的会话的表是否已经创建过了；
private Map<String, Boolean> gChatTables =null;
private Map<String, Boolean> pChatTables =null;
```



## 1.2 用户管理

这个类主要用来操作数据库维护用户信息相关的数据，

```kotlin
public class UserDbHelper {

    // 表名
    public static final String TABLE_USERS = "users";
    public static final String TABLE_FOLLOWS = "follows";
    public static final String TABLE_FANS = "fans";
    public static final String TABLE_GROUP_MEMBERS = "group_members";
    public static final String TABLE_ACCOUNT = "account";
    
}
```

数据库维护了5个表，分别为：



| 定义       | 用途                                         |
| ---------- | -------------------------------------------- |
| 用户表     | 查看过的所有用户的表，用于快速获取相关信息。 |
| 关注表     | 记录用户的关注情况                           |
| 粉丝表     | 记录用户的粉丝情况                           |
| 群组用户   | 记录各个群组用户的情况                       |
| 使用的账户 | 支持多账户登录                               |

其中，用户表信息全面；关注与粉丝表，只有ID和备注的昵称，因为可以做视图来索引用户表中的信息；

群组表使用群组ID和用户ID作为联合主键，关联用户表做视图；

在打开库时候创建的表和视图如下：

```kotlin
public static void onCreate(SQLiteDatabase db) {
    // 创建表
    db.execSQL(SQL_CREATE_USERS);
    db.execSQL(SQL_CREATE_FOLLOWS);
    db.execSQL(SQL_CREATE_FANS);
    db.execSQL(SQL_CREATE_GROUP_MEMBERS);
    db.execSQL(SQL_CREATE_ACCOUNT);

    // 创建视图
    db.execSQL(SQL_CREATE_FOLLOW_VIEW);
    db.execSQL(SQL_CREATE_FAN_VIEW);
    db.execSQL(SQL_CREATE_MUTUAL_VIEW);
    db.execSQL(SQL_CREATE_GROUP_MEM_VIEW);
}
```



## 1.3 消息管理

### 1.3.1 固定表

首先需要维护我们目前有哪些对话，以及加入了哪些群组；

```java
public static final String TABLE_PTOPIC = "p_topic";
public static final String TABLE_GTOPIC = "g_topic";
```

这2个表主要维护会话的基础信息，当前同步到哪里了，当前读到哪里了；群组涉及到图标和名称；

而消息其实还是单独存储的。

```java
public static final String TABLE_PCHAT = "pchat";
public static final String TABLE_PCHAT_UNREAD  = "pchat_unread";
```

使用两个表存储消息，

一个用于存储消息内容，一个用于表示哪些消息没有收到回执；如果没有收到回执的消息要定时重发；

而没有来得及应答的消息，由服务器端定期重发填写回执；

**谁发送谁负责重发。**



### 1.3.2 动态会话表

基础的表是固定的，而会话表是动态维护的，表名规则如下：

```java
public static String getPChatName(long fid){
    String tableName = "pchat_" + fid;
    return tableName;
}

public static String getGChatName(long gid){
    String tableName = "gchat_" + gid;
    return tableName;
}
```

这两个2用法还不一样，私聊的会话表是通过表关联才操作的，会话表是仅仅存储消息的MsgId就可以了；

而群组聊天不一样，这里的单独存储的，也就是以群组为单位存储消息的。

## 1.4 消息序号生成器

序号是使用单独一个表，每次取20或者100条，减少数据库操作次数，取的号用完了以后，再取。



## 2.  WebSocket网络通信



## 3. 消息与数据库同步

## 3.1 通信录

成功后，需要将数据库切换到当前用户；

如果好友列表为空，则尝试从本地初始化；

然后发送查询好友的请求；



## 3.2 会话列表

根据数据库初始化会话列表；远端服务器并不存储这个；这个需要用户自己管理；

1）当从双向好友列表中点击会话时候，创建这个会话，同时跳转到消息界面；

2）每次收到消息时候都要更新Topic的最新的消息，这里检查是否需要建立；

3）ChatSession 用于管理业务逻辑的相关部分；而Topic主要是界面的显示的列表与数据库对应；因为服务器不管理用户的这个对话表；服务器只有群组的信息；

ChatSessionManager管理ChatSession ，这里用于管理发送文本、音频、附件、图片，4种消息的逻辑；发送后同步最后的消息到界面；



## 3.3 发送消息的可靠性

ChatSessionManager处理发送的封装和界面消息的封装；

1）链接重新建立，登录成功后：重新加载并发送的数据库中所有的服务器未应答的消息；

2）发出去的消息没有应答的消息，都在ChatSessionManager统一管理，定时重发；直到服务器给出应答；

重发的消息应该是10秒，如果超过1分钟就认为发送失败；

3） 链接重新建立，登录成功后：与远端同步消息，并且将所有未应答的消息，重发应答；

4）对于未应答的消息，会从服务器重复收到，这个时候需要及时应答；