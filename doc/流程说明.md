# 一、 初始化

## 1.1应用中

启动后，在APP中设置初始化context以及服务器IP，

```kotlin
class App : Application() {

    override fun onCreate() {
        super.onCreate()

        // 全局初始化 SDK + WebSocket 服务
        GlobalData.init(this, "192.168.1.2:7817")
    }
}
```

这里设置一下基础信息，并启动websocket链接和前台服务线程。

```kotlin
fun init(ctx: Context, domain:String){
            // 设置与sdk的通知接口
            SdkGlobalData.addCallback(eventListener)
            SdkGlobalData.init(ctx)

            val appContext = ctx.applicationContext
            WebSocketClient.instance!!.setDomain(domain)
            WebSocketClient.instance!!.setFileServerDomain(domain)
            WebSocketClient.instance!!.setContext(appContext)

            // 启动后台服务（前台服务）
            val intent = Intent(appContext, WebSocketService::class.java)
            appContext.startService(intent)
        }
```

## 1.2 SDK中

### 1.2.1 登录成功

服务器连接成功后，会发送hello消息，带着以前的key print以及校验信息，如果没有过期，那么自动设置为登录成功，服务端会返回“用户操作类”的“登录成功”消息。

这个消息会在MsgEncode中触发登录成功函数：

```kotlin
fun loginOk(uid:Long){
        val resultMap = mapOf(
            "id" to uid.toString(),
            "result" to "ok"
        )
   
        SdkGlobalData.initLoad(uid)

        // sdk内部需要与服务器同步数据，然后通知界面跳转并刷新
        SdkGlobalData.userCallBackManager.invokeOnEventCallbacks(MsgEventType.LOGIN_OK, 0,0L, 0L, resultMap)
        updateState(Session.SessionState.READY)
    }
```



### 1.2.2 初始化

 初始化的入口在这里：

```
 SdkGlobalData.initLoad(uid)
```

1） 根据用户ID切换用户到相应的DB，这里客户端设计为支持多用户；

2）如果会话列表为空，尝试加载历史会话列表，这里分为：私聊和群聊；并选择第1个会话作为默认的聊天会话；如果没有历史会话，那么这里的默认会话就没有设置；

```kotlin
currentChatFid = 0L
```

3) 如果关注列表和粉丝列表为空，尝试数据库加载，并计算“互相关注”列表，如果之前没有默认会话，则默认的会话设置为第一个互粉的好友；

4）向服务器请求关注列表，和粉丝列表；

5）对当前的历史会话逐个加载历史聊天记录

```kotlin
synchronized(chatTopicList){
     ChatSessionManager.loadMessageOnLogin(chatTopicList)
}

 fun loadMessageOnLogin(chatTopicList :LinkedHashMap<Long, Topic>){
        var lstTm = 0L
        if (!bInit){
            lstTm = loadPMessageFormDb(chatTopicList)
            bInit = true
        }

        loadPMessageFromServer(lstTm)

    }
```

逐个会话，尝试加载各个会话中最后的200条数据; 加载后，更新会话的信息；

这里的主要函数是：

```
fun loadMessage(lst:  List<MessageData>, t:Topic):Long
```

**这里做了几件事：**

- 识别未发送成功的消息，等待重发；
- 识别收到的消息，没有给回执的，直接给接收回执；
- 识别未读的消息，等待用户阅读；
- 设置会话的属性：最后一条消息，未读的数量；



之后按照最后的msgID申请从服务器同步数据;