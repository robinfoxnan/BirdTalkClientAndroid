# 一、 初始化

## 1.1应用中

启动后，在APP中设置初始化context以及服务器IP，

```kotlin
class App : Application() {

    override fun onCreate() {
        super.onCreate()

        // 全局初始化 SDK + WebSocket 服务
        GlobalData.init(this, "192.168.1.2:7817")
    }
}
```

这里设置一下基础信息，并启动websocket链接和前台服务线程。

```kotlin
fun init(ctx: Context, domain:String){
            // 设置与sdk的通知接口
            SdkGlobalData.addCallback(eventListener)
            SdkGlobalData.init(ctx)

            val appContext = ctx.applicationContext
            WebSocketClient.instance!!.setDomain(domain)
            WebSocketClient.instance!!.setFileServerDomain(domain)
            WebSocketClient.instance!!.setContext(appContext)

            // 启动后台服务（前台服务）
            val intent = Intent(appContext, WebSocketService::class.java)
            appContext.startService(intent)
        }
```

## 1.2 SDK中

### 1.2.1 登录成功

服务器连接成功后，会发送hello消息，带着以前的key print以及校验信息，如果没有过期，那么自动设置为登录成功，服务端会返回“用户操作类”的“登录成功”消息。

这个消息会在MsgEncode中触发登录成功函数：

```kotlin
fun loginOk(uid:Long){
        val resultMap = mapOf(
            "id" to uid.toString(),
            "result" to "ok"
        )
   
        SdkGlobalData.initLoad(uid)

        // sdk内部需要与服务器同步数据，然后通知界面跳转并刷新
        SdkGlobalData.userCallBackManager.invokeOnEventCallbacks(MsgEventType.LOGIN_OK, 0,0L, 0L, resultMap)
        updateState(Session.SessionState.READY)
    }
```



### 1.2.2 初始化

 初始化的入口在这里：

```
 SdkGlobalData.initLoad(uid)
```

1） 根据用户ID切换用户到相应的DB，这里客户端设计为支持多用户；

2）如果会话列表为空，尝试加载历史会话列表，这里分为：私聊和群聊；并选择第1个会话作为默认的聊天会话；如果没有历史会话，那么这里的默认会话就没有设置；

```kotlin
currentChatFid = 0L
```

3) 如果关注列表和粉丝列表为空，尝试数据库加载，并计算“互相关注”列表，如果之前没有默认会话，则默认的会话设置为第一个互粉的好友；

4）向服务器请求关注列表，和粉丝列表；

5）对当前的历史会话逐个加载历史聊天记录

```kotlin
synchronized(chatTopicList){
     ChatSessionManager.loadMessageOnLogin(chatTopicList)
}

 fun loadMessageOnLogin(chatTopicList :LinkedHashMap<Long, Topic>){
        var lstTm = 0L
        if (!bInit){
            lstTm = loadPMessageFormDb(chatTopicList)
            bInit = true
        }

        loadPMessageFromServer(lstTm)

    }
```

逐个会话，尝试加载各个会话中最后的200条数据; 加载后，更新会话的信息；

这里的主要函数是：

```
fun loadMessage(lst:  List<MessageData>, t:Topic):Long
```

**这里做了几件事：**

- 识别未发送成功的消息，等待重发；
- 识别收到的消息，没有给回执的，直接给接收回执；
- 识别未读的消息，等待用户阅读；
- 设置会话的属性：最后一条消息，未读的数量；



针对私聊对话，之后按照最后的msgID申请从服务器同步数据;

- 从消息列表中找到最后一条消息的msgId，如果能找到，那么就是按照正向加载，服务器会最多返回100条数据；接收的条目如果等于100条，则应该继续加载；如果少于100，则不需要了；
- 如果本地数据库没有消息，那么可能是多终端登录，那么则应该反向加载；这里传递一个最大值就可以了；

而群聊的不太一样，群聊的需要根据ID去服务端逐个加载：

- 默认的是反向的加载，

总结：

1. 私聊的本地数据是连续，保证从后向前一直存在，加载时候整体加载，因为服务器端不区分私聊会话。

2. 群聊的数据不一定是连续的，因为客户可能长时间未登录，群内消息太多，全部加载不现实；所以每次与服务器只同步最新的数据；

   更新的整块的数据肯定是连续的，除了最前一条需要检测是否已经覆盖了以前的消息，那么后边的部分都标记为“连续”，返回的第1条默认设置为需要向前同步，但是如果第1条单独插入时候发现已经存在了，那么证明已经有完整的消息块了。

   ```
       BACKWARD,   // 前侧边界，需要加载
       FORWARD,    // 后侧边界，需要加载
       CONTINUOUS,  // 加载整块消息的中间部分
   ```



# 二、进入会话



# 三、消息同步

## 3.1 发方重发

## 3.2 发方查询回执

## 3.3 几种状态

| 发方状态                                                   | 收方状态                                                     | 发方流程                                                     | 收方流程                                                     |
| ---------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1）在线                                                    | 1）在线                                                      | 先收到服务器回执，<br />然后收到收方接受回执，<br />         | 接收时候自动给接收回执，<br />当滚动窗口时候设置阅读回执；   |
| 1）在线                                                    | 1）不在线，<br />2）之后上线                                 | 正常情况下，接收回执能收到<br />                             | 先收到服务器回执，<br />之后加载历史消息，上线同步消息，自动给接收回执 |
| 1）发送消息后下线，<br /><br />4）上线时候收方已经给了回执 | 2）离线，没有收到消息，<br />3）上线后发送接收回执，然后离线 | 发送方重启后，不会收到接收回执；<br />这个时候需要主动查询相关消息的接收回执； | 收到消息后自动给接收回执；                                   |
|                                                            |                                                              |                                                              |                                                              |



## 3.4 Topic 与ChatSession

Topic主要是是给会话列表控件使用的数据源，而ChatSession是封装了相关的聊天数据的管理；

SdkGlobalData中使用map管理的Topic和ChatSession，私聊的Id等于好友Id，而群组使用负数；

- 加载Topic列表时候，内部还是群组ID，但是索引使用负数；这里是为了方便管理；
  ```
  chatTopicList[-t.tid] = t
  ```
- chatSession 也是类似；

相关的同步流程

1. SdkGlobalData.initLoad() 中会从数据库加载Topic列表。